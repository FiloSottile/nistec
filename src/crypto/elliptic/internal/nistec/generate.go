// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:build ignore

package main

import (
	"bytes"
	"crypto/elliptic"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
)

var curves = []struct {
	P         string
	Element   string
	Params    *elliptic.CurveParams
	BuildTags string
}{
	{
		P:       "P224",
		Element: "fiat.P224Element",
		Params:  elliptic.P224().Params(),
	},
	{
		P:       "P256",
		Element: "fiat.P256Element",
		Params:  elliptic.P256().Params(),
	},
	{
		P:       "P384",
		Element: "fiat.P384Element",
		Params:  elliptic.P384().Params(),
	},
	{
		P:       "P521",
		Element: "fiat.P521Element",
		Params:  elliptic.P521().Params(),
	},
}

func main() {
	t := template.Must(template.New("tmplNISTEC").Parse(tmplNISTEC))

	for _, c := range curves {
		p := strings.ToLower(c.P)
		elementLen := (c.Params.BitSize + 7) / 8
		B := fmt.Sprintf("%#v", c.Params.B.FillBytes(make([]byte, elementLen)))
		G := fmt.Sprintf("%#v", elliptic.Marshal(c.Params, c.Params.Gx, c.Params.Gy))

		log.Printf("Generating %s.go...", p)
		f, err := os.Create(p + ".go")
		if err != nil {
			log.Fatal(err)
		}
		buf := &bytes.Buffer{}
		if err := t.Execute(buf, map[string]interface{}{
			"P": c.P, "p": p, "B": B, "G": G,
			"Element": c.Element, "ElementLen": elementLen,
			"BuildTags": c.BuildTags,
		}); err != nil {
			log.Fatal(err)
		}
		out, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatal(err)
		}
		if _, err := f.Write(out); err != nil {
			log.Fatal(err)
		}
		if err := f.Close(); err != nil {
			log.Fatal(err)
		}
	}
}

const tmplNISTEC = `// Copyright 2022 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Code generated by generate.go. DO NOT EDIT.

{{ if .BuildTags }}
//go:build {{ .BuildTags }}
{{ end }}

package nistec

import (
	"crypto/elliptic/internal/fiat"
	"crypto/subtle"
	"errors"
)

var {{.p}}B, _ = new({{.Element}}).SetBytes({{.B}})

var {{.p}}G, _ = New{{.P}}Point().SetBytes({{.G}})

const {{.p}}ElementLength = {{ .ElementLen }}

// {{.P}}Point is a {{.P}} point. The zero value is NOT valid.
type {{.P}}Point struct {
	// The point is represented in projective coordinates (X:Y:Z),
	// where x = X/Z and y = Y/Z.
	x, y, z *{{.Element}}
}

// New{{.P}}Point returns a new {{.P}}Point representing the point at infinity point.
func New{{.P}}Point() *{{.P}}Point {
	return &{{.P}}Point{
		x: new({{.Element}}),
		y: new({{.Element}}).One(),
		z: new({{.Element}}),
	}
}

// New{{.P}}Generator returns a new {{.P}}Point set to the canonical generator.
func New{{.P}}Generator() *{{.P}}Point {
	return (&{{.P}}Point{
		x: new({{.Element}}),
		y: new({{.Element}}),
		z: new({{.Element}}),
	}).Set({{.p}}G)
}

// Set sets p = q and returns p.
func (p *{{.P}}Point) Set(q *{{.P}}Point) *{{.P}}Point {
	p.x.Set(q.x)
	p.y.Set(q.y)
	p.z.Set(q.z)
	return p
}

// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
// the curve, it returns nil and an error, and the receiver is unchanged.
// Otherwise, it returns p.
func (p *{{.P}}Point) SetBytes(b []byte) (*{{.P}}Point, error) {
	switch {
	// Point at infinity.
	case len(b) == 1 && b[0] == 0:
		return p.Set(New{{.P}}Point()), nil

	// Uncompressed form.
	case len(b) == 1+2*{{.p}}ElementLength && b[0] == 4:
		x, err := new({{.Element}}).SetBytes(b[1 : 1+{{.p}}ElementLength])
		if err != nil {
			return nil, err
		}
		y, err := new({{.Element}}).SetBytes(b[1+{{.p}}ElementLength:])
		if err != nil {
			return nil, err
		}
		if err := {{.p}}CheckOnCurve(x, y); err != nil {
			return nil, err
		}
		p.x.Set(x)
		p.y.Set(y)
		p.z.One()
		return p, nil

	// Compressed form
	case len(b) == 1+{{.p}}ElementLength && b[0] == 0:
		return nil, errors.New("unimplemented") // TODO(filippo)

	default:
		return nil, errors.New("invalid {{.P}} point encoding")
	}
}

func {{.p}}CheckOnCurve(x, y *{{.Element}}) error {
	// x³ - 3x + b.
	x3 := new({{.Element}}).Square(x)
	x3.Mul(x3, x)

	threeX := new({{.Element}}).Add(x, x)
	threeX.Add(threeX, x)

	x3.Sub(x3, threeX)
	x3.Add(x3, {{.p}}B)

	// y² = x³ - 3x + b
	y2 := new({{.Element}}).Square(y)

	if x3.Equal(y2) != 1 {
		return errors.New("{{.P}} point not on curve")
	}
	return nil
}

// Bytes returns the uncompressed or infinity encoding of p, as specified in
// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
// infinity is shorter than all other encodings.
func (p *{{.P}}Point) Bytes() []byte {
	// This function is outlined to make the allocations inline in the caller
	// rather than happen on the heap.
	var out [133]byte
	return p.bytes(&out)
}

func (p *{{.P}}Point) bytes(out *[133]byte) []byte {
	if p.z.IsZero() == 1 {
		return append(out[:0], 0)
	}

	zinv := new({{.Element}}).Invert(p.z)
	xx := new({{.Element}}).Mul(p.x, zinv)
	yy := new({{.Element}}).Mul(p.y, zinv)

	buf := append(out[:0], 4)
	buf = append(buf, xx.Bytes()...)
	buf = append(buf, yy.Bytes()...)
	return buf
}

// Add sets q = p1 + p2, and returns q. The points may overlap.
func (q *{{.P}}Point) Add(p1, p2 *{{.P}}Point) *{{.P}}Point {
	// Complete addition formula for a = -3 from "Complete addition formulas for
	// prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.

	t0 := new({{.Element}}).Mul(p1.x, p2.x)   // t0 := X1 * X2
	t1 := new({{.Element}}).Mul(p1.y, p2.y)   // t1 := Y1 * Y2
	t2 := new({{.Element}}).Mul(p1.z, p2.z)   // t2 := Z1 * Z2
	t3 := new({{.Element}}).Add(p1.x, p1.y)   // t3 := X1 + Y1
	t4 := new({{.Element}}).Add(p2.x, p2.y)   // t4 := X2 + Y2
	t3.Mul(t3, t4)                            // t3 := t3 * t4
	t4.Add(t0, t1)                            // t4 := t0 + t1
	t3.Sub(t3, t4)                            // t3 := t3 - t4
	t4.Add(p1.y, p1.z)                        // t4 := Y1 + Z1
	x3 := new({{.Element}}).Add(p2.y, p2.z)   // X3 := Y2 + Z2
	t4.Mul(t4, x3)                            // t4 := t4 * X3
	x3.Add(t1, t2)                            // X3 := t1 + t2
	t4.Sub(t4, x3)                            // t4 := t4 - X3
	x3.Add(p1.x, p1.z)                        // X3 := X1 + Z1
	y3 := new({{.Element}}).Add(p2.x, p2.z)   // Y3 := X2 + Z2
	x3.Mul(x3, y3)                            // X3 := X3 * Y3
	y3.Add(t0, t2)                            // Y3 := t0 + t2
	y3.Sub(x3, y3)                            // Y3 := X3 - Y3
	z3 := new({{.Element}}).Mul({{.p}}B, t2)  // Z3 := b * t2
	x3.Sub(y3, z3)                            // X3 := Y3 - Z3
	z3.Add(x3, x3)                            // Z3 := X3 + X3
	x3.Add(x3, z3)                            // X3 := X3 + Z3
	z3.Sub(t1, x3)                            // Z3 := t1 - X3
	x3.Add(t1, x3)                            // X3 := t1 + X3
	y3.Mul({{.p}}B, y3)                       // Y3 := b * Y3
	t1.Add(t2, t2)                            // t1 := t2 + t2
	t2.Add(t1, t2)                            // t2 := t1 + t2
	y3.Sub(y3, t2)                            // Y3 := Y3 - t2
	y3.Sub(y3, t0)                            // Y3 := Y3 - t0
	t1.Add(y3, y3)                            // t1 := Y3 + Y3
	y3.Add(t1, y3)                            // Y3 := t1 + Y3
	t1.Add(t0, t0)                            // t1 := t0 + t0
	t0.Add(t1, t0)                            // t0 := t1 + t0
	t0.Sub(t0, t2)                            // t0 := t0 - t2
	t1.Mul(t4, y3)                            // t1 := t4 * Y3
	t2.Mul(t0, y3)                            // t2 := t0 * Y3
	y3.Mul(x3, z3)                            // Y3 := X3 * Z3
	y3.Add(y3, t2)                            // Y3 := Y3 + t2
	x3.Mul(t3, x3)                            // X3 := t3 * X3
	x3.Sub(x3, t1)                            // X3 := X3 - t1
	z3.Mul(t4, z3)                            // Z3 := t4 * Z3
	t1.Mul(t3, t0)                            // t1 := t3 * t0
	z3.Add(z3, t1)                            // Z3 := Z3 + t1

	q.x.Set(x3)
	q.y.Set(y3)
	q.z.Set(z3)
	return q
}

// Double sets q = p + p, and returns q. The points may overlap.
func (q *{{.P}}Point) Double(p *{{.P}}Point) *{{.P}}Point {
	// Complete addition formula for a = -3 from "Complete addition formulas for
	// prime order elliptic curves" (https://eprint.iacr.org/2015/1060), §A.2.

	t0 := new({{.Element}}).Square(p.x)      // t0 := X ^ 2
	t1 := new({{.Element}}).Square(p.y)      // t1 := Y ^ 2
	t2 := new({{.Element}}).Square(p.z)      // t2 := Z ^ 2
	t3 := new({{.Element}}).Mul(p.x, p.y)    // t3 := X * Y
	t3.Add(t3, t3)                           // t3 := t3 + t3
	z3 := new({{.Element}}).Mul(p.x, p.z)    // Z3 := X * Z
	z3.Add(z3, z3)                           // Z3 := Z3 + Z3
	y3 := new({{.Element}}).Mul({{.p}}B, t2) // Y3 := b * t2
	y3.Sub(y3, z3)                           // Y3 := Y3 - Z3
	x3 := new({{.Element}}).Add(y3, y3)      // X3 := Y3 + Y3
	y3.Add(x3, y3)                           // Y3 := X3 + Y3
	x3.Sub(t1, y3)                           // X3 := t1 - Y3
	y3.Add(t1, y3)                           // Y3 := t1 + Y3
	y3.Mul(x3, y3)                           // Y3 := X3 * Y3
	x3.Mul(x3, t3)                           // X3 := X3 * t3
	t3.Add(t2, t2)                           // t3 := t2 + t2
	t2.Add(t2, t3)                           // t2 := t2 + t3
	z3.Mul({{.p}}B, z3)                      // Z3 := b * Z3
	z3.Sub(z3, t2)                           // Z3 := Z3 - t2
	z3.Sub(z3, t0)                           // Z3 := Z3 - t0
	t3.Add(z3, z3)                           // t3 := Z3 + Z3
	z3.Add(z3, t3)                           // Z3 := Z3 + t3
	t3.Add(t0, t0)                           // t3 := t0 + t0
	t0.Add(t3, t0)                           // t0 := t3 + t0
	t0.Sub(t0, t2)                           // t0 := t0 - t2
	t0.Mul(t0, z3)                           // t0 := t0 * Z3
	y3.Add(y3, t0)                           // Y3 := Y3 + t0
	t0.Mul(p.y, p.z)                         // t0 := Y * Z
	t0.Add(t0, t0)                           // t0 := t0 + t0
	z3.Mul(t0, z3)                           // Z3 := t0 * Z3
	x3.Sub(x3, z3)                           // X3 := X3 - Z3
	z3.Mul(t0, t1)                           // Z3 := t0 * t1
	z3.Add(z3, z3)                           // Z3 := Z3 + Z3
	z3.Add(z3, z3)                           // Z3 := Z3 + Z3

	q.x.Set(x3)
	q.y.Set(y3)
	q.z.Set(z3)
	return q
}

// Select sets q to p1 if cond == 1, and to p2 if cond == 0.
func (q *{{.P}}Point) Select(p1, p2 *{{.P}}Point, cond int) *{{.P}}Point {
	q.x.Select(p1.x, p2.x, cond)
	q.y.Select(p1.y, p2.y, cond)
	q.z.Select(p1.z, p2.z, cond)
	return q
}

// ScalarMult sets p = scalar * q, and returns p.
func (p *{{.P}}Point) ScalarMult(q *{{.P}}Point, scalar []byte) *{{.P}}Point {
	// table holds the first 16 multiples of q. The explicit new{{.P}}Point calls
	// get inlined, letting the allocations live on the stack.
	var table = [16]*{{.P}}Point{
		New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(),
		New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(),
		New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(),
		New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(), New{{.P}}Point(),
	}
	for i := 1; i < 16; i++ {
        table[i].Add(table[i-1], q)
	}

	// Instead of doing the classic double-and-add chain, we do it with a
	// four-bit window: we double four times, and then add [0-15]P.
	t := New{{.P}}Point()
	p.Set(New{{.P}}Point())
	for _, byte := range scalar {
		p.Double(p)
		p.Double(p)
		p.Double(p)
		p.Double(p)

		for i := uint8(0); i < 16; i++ {
			cond := subtle.ConstantTimeByteEq(byte>>4, i)
			t.Select(table[i], t, cond)
		}
		p.Add(p, t)

		p.Double(p)
		p.Double(p)
		p.Double(p)
		p.Double(p)

		for i := uint8(0); i < 16; i++ {
			cond := subtle.ConstantTimeByteEq(byte&0b1111, i)
			t.Select(table[i], t, cond)
		}
		p.Add(p, t)
	}

	return p
}
`
